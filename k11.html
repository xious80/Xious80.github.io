<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <title>Dynamiskt 10x10 Korsord – Växlande lägen</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #fafafa;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    /* Knapparna ligger högst upp */
    #buttons {
      margin-bottom: 10px;
    }
    .button {
      margin: 5px;
      padding: 60px 120px;
      background: #0078D7;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 3rem;
    }
    /* Tipsrutan visas precis under knapparna */
    #selectedClue {
      margin-bottom: 10px;
      font-size: 1.5rem;
      font-weight: bold;
    }
    /* Gridet med 10 jämnt fördelade kolumner */
    .grid {
      display: grid;
      grid-gap: 2px;
      width: 100%;
      grid-template-columns: repeat(10, 1fr);
    }
    /* Varje cell-wrapper behåller en kvadratisk form med aspect-ratio */
    .cell-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
    }
    /* Celler: fast fontstorlek (4rem) så att bokstaven fyller rutan bättre */
    .cell {
      width: 100%;
      height: 100%;
      font-size: 4rem;
      text-transform: uppercase;
      text-align: center;
      border: 1px solid #ccc;
      box-sizing: border-box;
      background: #fff;
    }
    .cell[disabled] {
      background: #eee;
    }
    .number {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #555;
      pointer-events: none;
    }
    /* Tjockare kanter i början/slut av ordet */
    .start-across .cell {
      border-left: 2px solid black;
    }
    .end-across .cell {
      border-right: 2px solid black;
    }
    .start-down .cell {
      border-top: 2px solid black;
    }
    .end-down .cell {
      border-bottom: 2px solid black;
    }
    .clues, .score {
      margin-top: 20px;
      text-align: left;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    /* Log-ruta */
    #log {
      margin-top: 20px;
      text-align: left;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      background: #eee;
      padding: 10px;
      border: 1px solid #ccc;
      font-size: 12px;
    }
    /* Korrekt svar visas centrerat längst ned i cellen */
    .correct-letter {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 1rem;
      color: #555;
    }
  </style>
</head>
<body>
  <div id="buttons">
    <button class="button" onclick="generateCrossword()">Nytt korsord</button>
    <button class="button" onclick="checkAnswers()">Kontrollera svar</button>
  </div>
  
  <!-- Tipsrutan visas precis under knapparna -->
  <div id="selectedClue">Klicka på en ruta med siffra för att se ledtråden (och riktning)</div>
  
  <div class="grid" id="grid"></div>
  <div class="clues" id="clues"></div>
  <div class="score" id="score"></div>
  
  <!-- Log-ruta för felsökningsmeddelanden -->
  <div id="log"></div>
  
  <script>
    // Global växlingsvariabel: toggleMode % 2 == 0 => standardläge, annars alternativt läge.
    let toggleMode = 0;
    
    // Loggningsfunktion: skriver ut meddelanden i konsolen och i log-div.
    function logMessage(message) {
      console.log(message);
      const logDiv = document.getElementById('log');
      const p = document.createElement('p');
      p.textContent = message;
      logDiv.appendChild(p);
    }
    
    // Global variabel för aktivt ord (det ord vars startcell du klickar på).
    let activeWord = null;
    // WordBank laddas från wordbank.json (se filen separat).
    let wordBank = [];
    
    // Läs in wordbank från den externa filen.
    fetch('wordbank.json')
      .then(response => {
        if (!response.ok) throw new Error("Status " + response.status);
        return response.json();
      })
      .then(data => {
        wordBank = data;
        logMessage("Wordbank inläst: " + wordBank.length + " ord.");
        generateCrossword();
      })
      .catch(error => { logMessage("Fel vid inläsning av wordbank.json: " + error); });
    
    // Hjälpfunktion för att kontrollera om ett ord får plats i gridet.
    function canPlace(word, r, c, dir, grid, size) {
      if (dir === "across") {
        if (c + word.length > size) return false;
      } else {
        if (r + word.length > size) return false;
      }
      for (let i = 0; i < word.length; i++) {
        let rr = (dir === "across") ? r : r + i;
        let cc = (dir === "across") ? c + i : c;
        if (grid[rr][cc] !== null && grid[rr][cc] !== word[i]) return false;
      }
      return true;
    }
    
    // Hjälpfunktion för att placera ett ord i gridet.
    function placeWord(word, clue, r, c, dir, grid, placedWords) {
      let positions = [];
      for (let i = 0; i < word.length; i++) {
        let rr = (dir === "across") ? r : r + i;
        let cc = (dir === "across") ? c + i : c;
        grid[rr][cc] = word[i];
        positions.push({ r: rr, c: cc });
      }
      placedWords.push({ word, clue, row: r, col: c, dir, positions });
    }
    
    // Standardläge: placera flera korsande ord i ett 10×10‑rutnät.
    function generateStandardMode() {
      const size = 10;
      let grid = Array.from({ length: size }, () => Array(size).fill(null));
      let placedWords = [];
      let remaining = wordBank.slice().sort((a, b) => b.word.length - a.word.length);
      
      // Placera första ordet centrerat horisontellt.
      if (remaining.length > 0) {
        const first = remaining.shift();
        let r = Math.floor(size / 2);
        let c = Math.floor((size - first.word.length) / 2);
        placeWord(first.word, first.clue, r, c, "across", grid, placedWords);
        logMessage("Första ord placerat: " + first.word + " på rad " + (r + 1) + ", kolumn " + (c + 1));
      }
      
      // Försök placera övriga ord med gemensam bokstav.
      let progress = true;
      while (progress && remaining.length > 0) {
        progress = false;
        for (let i = remaining.length - 1; i >= 0; i--) {
          const candidate = remaining[i];
          let placed = false;
          for (let placedObj of placedWords) {
            for (let i1 = 0; i1 < placedObj.word.length; i1++) {
              const letter = placedObj.word[i1];
              for (let j = 0; j < candidate.word.length; j++) {
                if (candidate.word[j] === letter) {
                  const newDir = (placedObj.dir === "across") ? "down" : "across";
                  let newRow, newCol;
                  if (newDir === "down") {
                    newRow = placedObj.row - j;
                    newCol = placedObj.col + i1;
                  } else {
                    newRow = placedObj.row + i1;
                    newCol = placedObj.col - j;
                  }
                  if (newRow < 0 || newCol < 0) continue;
                  if (canPlace(candidate.word, newRow, newCol, newDir, grid, size)) {
                    placeWord(candidate.word, candidate.clue, newRow, newCol, newDir, grid, placedWords);
                    remaining.splice(i, 1);
                    placed = true;
                    progress = true;
                    logMessage("Ord placerat: " + candidate.word + " (" + newDir + ") på rad " + (newRow + 1) + ", kolumn " + (newCol + 1));
                    break;
                  }
                }
              }
              if (placed) break;
            }
            if (placed) break;
          }
        }
      }
      
      return { grid, placedWords, size };
    }
    
    // Alternativt läge: placera först ett lodrätt ord och försök sedan placera horisontella ord
    // längs med varje rad där det lodräta ordet finns.
    function generateAlternateMode() {
      const size = 10;
      let grid = Array.from({ length: size }, () => Array(size).fill(null));
      let placedWords = [];
      
      // Välj en vertikal kandidat bland de ord som inte är längre än rutnätet.
      let verticalCandidates = wordBank.filter(x => x.word.length <= size);
      if (verticalCandidates.length === 0) {
        logMessage("Ingen lämplig vertikal kandidat hittades.");
        return { grid, placedWords, size };
      }
      verticalCandidates.sort((a, b) => b.word.length - a.word.length);
      let verticalWord = verticalCandidates[0];
      
      // Placera det lodräta ordet i mitten av gridet (kolumn = Math.floor(size/2), från rad 0).
      let verticalCol = Math.floor(size / 2);
      let verticalRow = 0;
      placeWord(verticalWord.word, verticalWord.clue, verticalRow, verticalCol, "down", grid, placedWords);
      logMessage("Vertikalt ord placerat: " + verticalWord.word + " på kolumn " + (verticalCol + 1));
      
      // För varje rad där det lodräta ordet finns, försök placera ett horisontellt ord
      for (let r = verticalRow; r < verticalRow + verticalWord.word.length; r++) {
        let verticalChar = verticalWord.word[r - verticalRow];
        // Filtrera horisontella kandidater: ord som är inte samma som det lodräta och innehåller den aktuella bokstaven
        let horizontalCandidates = wordBank.filter(x =>
          x.word !== verticalWord.word && x.word.length <= size && x.word.includes(verticalChar)
        );
        if (horizontalCandidates.length === 0) {
          logMessage("Ingen horisontell kandidat för bokstaven " + verticalChar + " vid rad " + (r + 1));
          continue;
        }
        horizontalCandidates.sort((a, b) => b.word.length - a.word.length);
        let placed = false;
        for (let candidate of horizontalCandidates) {
          let L = candidate.word.length;
          // Försök hitta ett index i candidate.word där bokstaven matchar verticalChar
          for (let i = 0; i < L; i++) {
            if (candidate.word[i] === verticalChar) {
              // För att placerar horisontellt: bestäm startkolumn så att candidate[i] hamnar på verticalCol
              let horizontalCol = verticalCol - i;
              if (horizontalCol >= 0 && (horizontalCol + L) <= size) {
                if (canPlace(candidate.word, r, horizontalCol, "across", grid, size)) {
                  placeWord(candidate.word, candidate.clue, r, horizontalCol, "across", grid, placedWords);
                  logMessage("Horisontellt ord placerat: " + candidate.word + " på rad " + (r + 1) + ", kolumn " + (horizontalCol + 1));
                  placed = true;
                  break;
                }
              }
            }
          }
          if (placed) break;
        }
      }
      
      return { grid, placedWords, size };
    }
    
    // Huvudfunktion: Växla mellan standardläge och alternativt läge.
    function generateCrossword() {
      // Töm loggen
      document.getElementById('log').innerHTML = '';
      let gridData;
      if (toggleMode % 2 === 0) {
        logMessage("Standardläge genereras:");
        gridData = generateStandardMode();
      } else {
        logMessage("Alternativt läge genereras: Lodrätt ord med horisontella ord längs med det");
        gridData = generateAlternateMode();
      }
      renderGrid(gridData);
      toggleMode++;
    }
    
    // Funktion för att rendera grid och ledtrådar.
    function renderGrid(gridData) {
      const gridDiv = document.getElementById('grid');
      const cluesDiv = document.getElementById('clues');
      gridDiv.innerHTML = '';
      cluesDiv.innerHTML = '';
      const { grid, placedWords, size } = gridData;
      
      // Tilldela numrering till varje ords startcell.
      let numbering = Array.from({ length: size }, () => Array(size).fill(''));
      let num = 1;
      for (let obj of placedWords) {
        const r = obj.row, c = obj.col;
        if (!numbering[r][c]) {
          numbering[r][c] = num++;
        }
        obj.number = numbering[r][c];
      }
      
      // Skapa matriser för vilka celler som tillhör "across" respektive "down" ord.
      let acrossMatrix = Array.from({ length: size }, () => Array(size).fill(false));
      let downMatrix = Array.from({ length: size }, () => Array(size).fill(false));
      for (let obj of placedWords) {
        if (obj.dir === "across") {
          for (let pos of obj.positions) {
            acrossMatrix[pos.r][pos.c] = true;
          }
        } else {
          for (let pos of obj.positions) {
            downMatrix[pos.r][pos.c] = true;
          }
        }
      }
      
      gridDiv.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      let matrix = Array.from({ length: size }, () => Array(size).fill(null));
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (grid[r][c] !== null) {
            matrix[r][c] = { letter: grid[r][c] };
          }
        }
      }
      
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const wrapper = document.createElement('div');
          wrapper.className = 'cell-wrapper';
          if (matrix[r][c] && (c === 0 || !acrossMatrix[r][c - 1])) {
            wrapper.classList.add("start-across");
          }
          if (matrix[r][c] && (c === size - 1 || !acrossMatrix[r][c + 1])) {
            wrapper.classList.add("end-across");
          }
          if (matrix[r][c] && (r === 0 || !downMatrix[r - 1][c])) {
            wrapper.classList.add("start-down");
          }
          if (matrix[r][c] && (r === size - 1 || !downMatrix[r + 1][c])) {
            wrapper.classList.add("end-down");
          }
          
          const input = document.createElement('input');
          input.className = 'cell';
          input.maxLength = 1;
          input.dataset.pos = `${r}-${c}`;
          input.addEventListener("input", function() {
            this.value = this.value.toUpperCase().substring(0, 1);
            if (activeWord) {
              let pos = this.dataset.pos;
              let index = activeWord.positions.findIndex(p => `${p.r}-${p.c}` === pos);
              if (index !== -1 && index < activeWord.positions.length - 1) {
                let nextCoord = activeWord.positions[index + 1];
                let nextInput = document.querySelector(`input[data-pos="${nextCoord.r}-${nextCoord.c}"]`);
                if (nextInput) {
                  nextInput.focus();
                }
              }
            }
          });
          if (!matrix[r][c]) {
            input.disabled = true;
          } else {
            input.dataset.solution = matrix[r][c].letter;
          }
          
          if (numbering[r][c]) {
            const label = document.createElement('div');
            label.className = 'number';
            label.textContent = numbering[r][c];
            wrapper.appendChild(label);
            wrapper.addEventListener("click", function() {
              let pw = placedWords.find(w => w.row === r && w.col === c);
              if (pw) {
                activeWord = pw;
                document.getElementById('selectedClue').innerText =
                  pw.number + " " + (pw.dir === "across" 
                    ? "(vågrätt " + pw.word.length + ")" 
                    : "(lodrätt " + pw.word.length + ")") + ": " + pw.clue;
              }
            });
          }
          
          wrapper.appendChild(input);
          gridDiv.appendChild(wrapper);
        }
      }
      
      placedWords.sort((a, b) => a.number - b.number);
      cluesDiv.innerHTML = '<h2>Ledtrådar</h2>';
      placedWords.forEach(wordObj => {
        cluesDiv.innerHTML += `<p>${wordObj.number} ${wordObj.dir === "across" ?
          "(vågrätt " + wordObj.word.length + ")" : "(lodrätt " + wordObj.word.length + ")"}: ${wordObj.clue}</p>`;
      });
      
      logMessage("Placerade ord: " + placedWords.length);
    }
    
    // Kontrollera svaren – markerar rätt/fel och visar rätt svar centrerat längst ned.
    function checkAnswers() {
      const inputs = document.querySelectorAll('.cell');
      let correct = 0, total = 0;
      document.querySelectorAll('.correct-letter').forEach(e => e.remove());
      inputs.forEach(input => {
        if (!input.disabled && input.dataset.solution) {
          total++;
          const val = input.value.toUpperCase();
          const solution = input.dataset.solution.toUpperCase();
          if (val === solution) {
            correct++;
            input.style.backgroundColor = '#c6f6c6';
          } else {
            input.style.backgroundColor = '#f6f6c6';
            const corr = document.createElement('div');
            corr.className = 'correct-letter';
            corr.textContent = solution;
            input.parentElement.appendChild(corr);
          }
        }
      });
      document.getElementById('score').innerHTML = `<h3>Du fick ${correct} av ${total} bokstäver rätt.</h3>`;
    }
    
    // Huvudfunktionen: växla mellan standardläge och alternativt läge.
    function generateCrossword() {
      document.getElementById('log').innerHTML = '';
      let gridData;
      if (toggleMode % 2 === 0) {
        logMessage("Standardläge genereras:");
        gridData = generateStandardMode();
      } else {
        logMessage("Alternativt läge genereras: Långt lodrätt ord med horisontella ord längs med hela det lodräta.");
        gridData = generateAlternateMode();
      }
      renderGrid(gridData);
      toggleMode++;
    }
    
    // Kör korsordsgeneratorn vid sidladdning.
    window.onload = function() {
      // Wordbank hämtas innan generateCrossword kallas.
    };
  </script>
</body>
</html>
